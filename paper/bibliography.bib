
@inproceedings{cimini_effectiveness_2020,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {On the {Effectiveness} of {Higher}-{Order} {Logic} {Programming} in {Language}-{Oriented} {Programming}},
	isbn = {978-3-030-59025-3},
	doi = {10.1007/978-3-030-59025-3_7},
	abstract = {In previous work we have presented, a functional language-oriented programming language with languages as first-class-citizens. Language definitions can be bound to variables, passed to and returned by functions, and can be modified at run-time before being used. programs are compiled and executed in the higher-order logic programming language λProlog. In this paper, we describe our compilation methods, which highlight how the distinctive features of higher-order logic programming are a great fit in implementing a language-oriented programming language.},
	language = {en},
	booktitle = {Functional and {Logic} {Programming}},
	publisher = {Springer International Publishing},
	author = {Cimini, Matteo},
	editor = {Nakano, Keisuke and Sagonas, Konstantinos},
	year = {2020},
	keywords = {Functional programming, Higher-order logic programming, Language-oriented programming},
	pages = {106--123},
	file = {Full Text PDF:/home/hannah/Zotero/storage/MUY6NEAQ/Cimini - 2020 - On the Effectiveness of Higher-Order Logic Program.pdf:application/pdf},
}

@misc{noauthor_languages_nodate,
	title = {Languages as first-class citizens (vision paper) {\textbar} {Proceedings} of the 11th {ACM} {SIGPLAN} {International} {Conference} on {Software} {Language} {Engineering}},
	url = {https://dl.acm.org/doi/10.1145/3276604.3276983},
	urldate = {2022-11-14},
}

@article{vacchi_neverlang_2015,
	title = {Neverlang: {A} framework for feature-oriented language development},
	volume = {43},
	issn = {14778424},
	shorttitle = {Neverlang},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1477842415000056},
	doi = {10.1016/j.cl.2015.02.001},
	abstract = {Reuse in programming language development is an open research problem. Many authors have proposed frameworks for modular language development. These frameworks focus on maximizing code reuse, providing primitives for componentizing language implementations. There is also an open debate on combining feature-orientation with modular language development. Feature-oriented programming is a vision of computer programming in which features can be implemented separately, and then combined to build a variety of software products. However, even though feature-orientation and modular programming are strongly connected, modular language development frameworks are not usually meant primarily for feature-oriented language definition. In this paper we present a model of language development that puts feature implementation at the center, and describe its implementation in the Neverlang framework. The model has been evaluated through several languages implementations: in this paper, a state machine language is used as a means of comparison with other frameworks, and a JavaScript interpreter implementation is used to further illustrate the benefits that our model provides.},
	language = {en},
	urldate = {2022-11-14},
	journal = {Computer Languages, Systems \& Structures},
	author = {Vacchi, Edoardo and Cazzola, Walter},
	month = oct,
	year = {2015},
	pages = {1--40},
	file = {Vacchi and Cazzola - 2015 - Neverlang A framework for feature-oriented langua.pdf:/home/hannah/Zotero/storage/P26RJFG3/Vacchi and Cazzola - 2015 - Neverlang A framework for feature-oriented langua.pdf:application/pdf},
}

@incollection{pickering_language-oriented_2010,
	address = {Berkeley, CA},
	title = {Language-{Oriented} {Programming}},
	isbn = {978-1-4302-2390-0},
	url = {https://doi.org/10.1007/978-1-4302-2390-0_12},
	abstract = {In this chapter, you will begin by taking a look at what I mean by language-oriented programming, a term that has been used by many people to mean different things. I’ll also briefly discuss its advantages and disadvantages. Next, you’ll look at several different approaches to language-oriented programming in F\#. These techniques include using F\# literals to create little languages and using F\# quotations. You’ll spend the bulk of this chapter looking at examples where you create a language, then create an interpreter to execute that language. Finally, you’ll take a more detailed look at how languages are executed, including a performance comparison of interpreted or compiled execution techniques.},
	language = {en},
	urldate = {2022-11-14},
	booktitle = {Beginning {F}\#},
	publisher = {Apress},
	author = {Pickering, Robert},
	editor = {Pickering, Robert},
	year = {2010},
	doi = {10.1007/978-1-4302-2390-0_12},
	keywords = {Abstract Syntax, Arithmetic Expression, Combinator Library, Simple Element, Union Type},
	pages = {327--349},
}

@article{felleisen_programmable_2018,
	title = {A programmable programming language},
	volume = {61},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/3127323},
	doi = {10.1145/3127323},
	abstract = {As the software industry enters the era of language-oriented programming, it needs programmable programming languages.},
	number = {3},
	urldate = {2022-11-14},
	journal = {Communications of the ACM},
	author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram and Barzilay, Eli and McCarthy, Jay and Tobin-Hochstadt, Sam},
	month = feb,
	year = {2018},
	pages = {62--71},
}

@book{miller_programming_2012,
	address = {Cambridge},
	title = {Programming with {Higher}-{Order} {Logic}},
	isbn = {978-0-521-87940-8},
	url = {https://www.cambridge.org/core/books/programming-with-higherorder-logic/90460BBDEF7ADE2B2B738DD05A39ECC5},
	abstract = {Formal systems that describe computations over syntactic structures occur frequently in computer science. Logic programming provides a natural framework for encoding and animating such systems. However, these systems often embody variable binding, a notion that must be treated carefully at a computational level. This book aims to show that a programming language based on a simply typed version of higher-order logic provides an elegant, declarative means for providing such a treatment. Three broad topics are covered in pursuit of this goal. First, a proof-theoretic framework that supports a general view of logic programming is identified. Second, an actual language called λProlog is developed by applying this view to higher-order logic. Finally, a methodology for programming with specifications is exposed by showing how several computations over formal objects such as logical formulas, functional programs, and λ-terms and π-calculus expressions can be encoded in λProlog.},
	urldate = {2022-11-14},
	publisher = {Cambridge University Press},
	author = {Miller, Dale and Nadathur, Gopalan},
	year = {2012},
	doi = {10.1017/CBO9781139021326},
	file = {Snapshot:/home/hannah/Zotero/storage/E6JI93Q8/90460BBDEF7ADE2B2B738DD05A39ECC5.html:text/html},
}

@article{pfenning_higher-order_1988,
	title = {Higher-order abstract syntax},
	volume = {23},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/960116.54010},
	doi = {10.1145/960116.54010},
	abstract = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
	number = {7},
	urldate = {2022-11-14},
	journal = {ACM SIGPLAN Notices},
	author = {Pfenning, F. and Elliott, C.},
	month = jun,
	year = {1988},
	pages = {199--208},
	file = {Full Text PDF:/home/hannah/Zotero/storage/U2RA34NR/Pfenning and Elliott - 1988 - Higher-order abstract syntax.pdf:application/pdf},
}

@article{gabbay_n-prolog_1984,
	title = {N-{Prolog}: {An} extension of {Prolog} with hypothetical implications. {I}.},
	volume = {1},
	issn = {0743-1066},
	shorttitle = {N-{Prolog}},
	url = {https://www.sciencedirect.com/science/article/pii/0743106684900293},
	doi = {10.1016/0743-1066(84)90029-3},
	abstract = {An extension of PROLOG called N-PROLOG is presented. N-PROLOG allows hypothetical implications in the clauses. For clauses without implication, N-PROLOG acts like PROLOG. Examples are given to show the need for N-PROLOG. N-PROLOG is a self-reflecting language; it is equal to its own metalanguage. N-PROLOG is more suitable for expressing temporal behavior (change in time). Ordinary PROLOG is conceptually weaker than N-PROLOG.},
	language = {en},
	number = {4},
	urldate = {2022-11-14},
	journal = {The Journal of Logic Programming},
	author = {Gabbay, D. M. and Reyle, U.},
	month = dec,
	year = {1984},
	pages = {319--355},
	file = {ScienceDirect Full Text PDF:/home/hannah/Zotero/storage/L96U3UH2/Gabbay and Reyle - 1984 - N-Prolog An extension of Prolog with hypothetical.pdf:application/pdf},
}
