
@inproceedings{cimini_effectiveness_2020,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {On the {Effectiveness} of {Higher}-{Order} {Logic} {Programming} in {Language}-{Oriented} {Programming}},
	isbn = {978-3-030-59025-3},
	doi = {10.1007/978-3-030-59025-3_7},
	abstract = {In previous work we have presented, a functional language-oriented programming language with languages as first-class-citizens. Language definitions can be bound to variables, passed to and returned by functions, and can be modified at run-time before being used. programs are compiled and executed in the higher-order logic programming language λProlog. In this paper, we describe our compilation methods, which highlight how the distinctive features of higher-order logic programming are a great fit in implementing a language-oriented programming language.},
	language = {en},
	booktitle = {Functional and {Logic} {Programming}},
	publisher = {Springer International Publishing},
	author = {Cimini, Matteo},
	editor = {Nakano, Keisuke and Sagonas, Konstantinos},
	year = {2020},
	keywords = {Functional programming, Higher-order logic programming, Language-oriented programming},
	pages = {106--123},
	file = {Full Text PDF:/home/hannah/Zotero/storage/MUY6NEAQ/Cimini - 2020 - On the Effectiveness of Higher-Order Logic Program.pdf:application/pdf},
}

@article{gabbay_n-prolog_1984,
	title = {N-{Prolog}: {An} extension of {Prolog} with hypothetical implications. {I}.},
	volume = {1},
	issn = {0743-1066},
	shorttitle = {N-{Prolog}},
	url = {https://www.sciencedirect.com/science/article/pii/0743106684900293},
	doi = {10.1016/0743-1066(84)90029-3},
	abstract = {An extension of PROLOG called N-PROLOG is presented. N-PROLOG allows hypothetical implications in the clauses. For clauses without implication, N-PROLOG acts like PROLOG. Examples are given to show the need for N-PROLOG. N-PROLOG is a self-reflecting language; it is equal to its own metalanguage. N-PROLOG is more suitable for expressing temporal behavior (change in time). Ordinary PROLOG is conceptually weaker than N-PROLOG.},
	language = {en},
	number = {4},
	urldate = {2022-11-14},
	journal = {The Journal of Logic Programming},
	author = {Gabbay, D. M. and Reyle, U.},
	month = dec,
	year = {1984},
	pages = {319--355},
	file = {ScienceDirect Full Text PDF:/home/hannah/Zotero/storage/L96U3UH2/Gabbay and Reyle - 1984 - N-Prolog An extension of Prolog with hypothetical.pdf:application/pdf},
}

@article{pfenning_higher-order_1988,
	title = {Higher-order abstract syntax},
	volume = {23},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/960116.54010},
	doi = {10.1145/960116.54010},
	abstract = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
	number = {7},
	urldate = {2022-11-14},
	journal = {ACM SIGPLAN Notices},
	author = {Pfenning, F. and Elliott, C.},
	month = jun,
	year = {1988},
	pages = {199--208},
	file = {Full Text PDF:/home/hannah/Zotero/storage/U2RA34NR/Pfenning and Elliott - 1988 - Higher-order abstract syntax.pdf:application/pdf},
}

@book{miller_programming_2012,
	address = {Cambridge},
	title = {Programming with {Higher}-{Order} {Logic}},
	isbn = {978-0-521-87940-8},
	url = {https://www.cambridge.org/core/books/programming-with-higherorder-logic/90460BBDEF7ADE2B2B738DD05A39ECC5},
	abstract = {Formal systems that describe computations over syntactic structures occur frequently in computer science. Logic programming provides a natural framework for encoding and animating such systems. However, these systems often embody variable binding, a notion that must be treated carefully at a computational level. This book aims to show that a programming language based on a simply typed version of higher-order logic provides an elegant, declarative means for providing such a treatment. Three broad topics are covered in pursuit of this goal. First, a proof-theoretic framework that supports a general view of logic programming is identified. Second, an actual language called λProlog is developed by applying this view to higher-order logic. Finally, a methodology for programming with specifications is exposed by showing how several computations over formal objects such as logical formulas, functional programs, and λ-terms and π-calculus expressions can be encoded in λProlog.},
	urldate = {2022-11-14},
	publisher = {Cambridge University Press},
	author = {Miller, Dale and Nadathur, Gopalan},
	year = {2012},
	doi = {10.1017/CBO9781139021326},
	file = {Snapshot:/home/hannah/Zotero/storage/E6JI93Q8/90460BBDEF7ADE2B2B738DD05A39ECC5.html:text/html},
}

@article{felleisen_programmable_2018,
	title = {A programmable programming language},
	volume = {61},
	issn = {0001-0782},
	url = {https://doi.org/10.1145/3127323},
	doi = {10.1145/3127323},
	abstract = {As the software industry enters the era of language-oriented programming, it needs programmable programming languages.},
	number = {3},
	urldate = {2022-11-14},
	journal = {Communications of the ACM},
	author = {Felleisen, Matthias and Findler, Robert Bruce and Flatt, Matthew and Krishnamurthi, Shriram and Barzilay, Eli and McCarthy, Jay and Tobin-Hochstadt, Sam},
	month = feb,
	year = {2018},
	pages = {62--71},
}

@incollection{pickering_language-oriented_2010,
	address = {Berkeley, CA},
	title = {Language-{Oriented} {Programming}},
	isbn = {978-1-4302-2390-0},
	url = {https://doi.org/10.1007/978-1-4302-2390-0_12},
	abstract = {In this chapter, you will begin by taking a look at what I mean by language-oriented programming, a term that has been used by many people to mean different things. I’ll also briefly discuss its advantages and disadvantages. Next, you’ll look at several different approaches to language-oriented programming in F\#. These techniques include using F\# literals to create little languages and using F\# quotations. You’ll spend the bulk of this chapter looking at examples where you create a language, then create an interpreter to execute that language. Finally, you’ll take a more detailed look at how languages are executed, including a performance comparison of interpreted or compiled execution techniques.},
	language = {en},
	urldate = {2022-11-14},
	booktitle = {Beginning {F}\#},
	publisher = {Apress},
	author = {Pickering, Robert},
	editor = {Pickering, Robert},
	year = {2010},
	doi = {10.1007/978-1-4302-2390-0_12},
	keywords = {Abstract Syntax, Arithmetic Expression, Combinator Library, Simple Element, Union Type},
	pages = {327--349},
}

@article{vacchi_neverlang_2015,
	title = {Neverlang: {A} framework for feature-oriented language development},
	volume = {43},
	issn = {14778424},
	shorttitle = {Neverlang},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S1477842415000056},
	doi = {10.1016/j.cl.2015.02.001},
	abstract = {Reuse in programming language development is an open research problem. Many authors have proposed frameworks for modular language development. These frameworks focus on maximizing code reuse, providing primitives for componentizing language implementations. There is also an open debate on combining feature-orientation with modular language development. Feature-oriented programming is a vision of computer programming in which features can be implemented separately, and then combined to build a variety of software products. However, even though feature-orientation and modular programming are strongly connected, modular language development frameworks are not usually meant primarily for feature-oriented language definition. In this paper we present a model of language development that puts feature implementation at the center, and describe its implementation in the Neverlang framework. The model has been evaluated through several languages implementations: in this paper, a state machine language is used as a means of comparison with other frameworks, and a JavaScript interpreter implementation is used to further illustrate the benefits that our model provides.},
	language = {en},
	urldate = {2022-11-14},
	journal = {Computer Languages, Systems \& Structures},
	author = {Vacchi, Edoardo and Cazzola, Walter},
	month = oct,
	year = {2015},
	pages = {1--40},
	file = {Vacchi and Cazzola - 2015 - Neverlang A framework for feature-oriented langua.pdf:/home/hannah/Zotero/storage/P26RJFG3/Vacchi and Cazzola - 2015 - Neverlang A framework for feature-oriented langua.pdf:application/pdf},
}

@misc{cimini_languages_2018,
	title = {Languages as first-class citizens (vision paper) {\textbar} {Proceedings} of the 11th {ACM} {SIGPLAN} {International} {Conference} on {Software} {Language} {Engineering}},
	url = {https://dl.acm.org/doi/10.1145/3276604.3276983},
	urldate = {2022-11-14},
	author = {Cimini, Matteo},
	month = oct,
	year = {2018},
	file = {Languages as first-class citizens (vision paper) .pdf:/home/hannah/Zotero/storage/MVVVKWN6/Languages as first-class citizens (vision paper) .pdf:application/pdf},
}

@article{nadathur_higher-order_nodate,
	title = {Higher-{Order} {Logic} {Programming}},
	language = {en},
	author = {Nadathur, Gopalan and Miller, Dale},
	pages = {83},
	file = {Nadathur and Miller - Higher-Order Logic Programming.pdf:/home/hannah/Zotero/storage/R2Z3SDMQ/Nadathur and Miller - Higher-Order Logic Programming.pdf:application/pdf},
}

@misc{cimini_lang-n-play_2018,
	title = {Lang-n-play: a functional programming language with languages as first-class citizen},
	url = {https://github.com/mcimini/lang-n-play},
	author = {Cimini, Matteo},
	year = {2018},
	note = {https://github.com/mcimini/lang-n-play},
}

@inproceedings{erdweg_language_2012,
	address = {New York, NY, USA},
	series = {{LDTA} '12},
	title = {Language composition untangled},
	isbn = {978-1-4503-1536-4},
	url = {https://doi.org/10.1145/2427048.2427055},
	doi = {10.1145/2427048.2427055},
	abstract = {In language-oriented programming and modeling, software developers are largely concerned with the definition of domain-specific languages (DSLs) and their composition. While various implementation techniques and frameworks exist for defining DSLs, language composition has not obtained enough attention and is not well-enough understood. In particular, there is a lack of precise terminology for describing observations about language composition in theory and in existing language-development systems. To clarify the issue, we specify five forms of language composition: language extension, language restriction, language unification, self-extension, and extension composition. We illustrate this classification by various examples and apply it to discuss the performance of different language-development systems with respect to language composition. We hope that the terminology provided by our classification will enable more precise communication on language composition.},
	urldate = {2022-12-18},
	booktitle = {Proceedings of the {Twelfth} {Workshop} on {Language} {Descriptions}, {Tools}, and {Applications}},
	publisher = {Association for Computing Machinery},
	author = {Erdweg, Sebastian and Giarrusso, Paolo G. and Rendel, Tillmann},
	month = mar,
	year = {2012},
	keywords = {domain-specific language, language composition, language extension, language unification, self-extension},
	pages = {1--8},
	file = {Erdweg et al. - 2012 - Language composition untangled.pdf:/home/hannah/Zotero/storage/3KL7FBMF/Erdweg et al. - 2012 - Language composition untangled.pdf:application/pdf},
}

@inproceedings{butting_modeling_2018,
	address = {New York, NY, USA},
	series = {{SPLC} '18},
	title = {Modeling language variability with reusable language components},
	isbn = {978-1-4503-6464-5},
	url = {https://doi.org/10.1145/3233027.3233037},
	doi = {10.1145/3233027.3233037},
	abstract = {Proliferation of modeling languages has produced a great variety of similar languages whose individual maintenance is challenging and costly. Reusing the syntax and semantics of modeling languages and their heterogeneous constituents, however, is rarely systematic. Current research on modeling language reuse focuses on reusing abstract syntax in form of metamodel parts. Systematic reuse of static and dynamic semantics is yet to be achieved. We present an approach to compose syntax and semantics of independently developed modeling languages through language product lines and derive new stand-alone language products. Using the MontiCore language workbench, we implemented a mechanism to compose language syntaxes and the realization of their semantics in form of template-based code generators according to language product line configurations. Leveraging variability of product lines greatly facilitates reusing modeling language and alleviates their proliferation.},
	urldate = {2022-12-18},
	booktitle = {Proceedings of the 22nd {International} {Systems} and {Software} {Product} {Line} {Conference} - {Volume} 1},
	publisher = {Association for Computing Machinery},
	author = {Butting, Arvid and Eikermann, Robert and Kautz, Oliver and Rumpe, Bernhard and Wortmann, Andreas},
	month = sep,
	year = {2018},
	keywords = {language product lines, language variability, software language engineering},
	pages = {65--75},
	file = {Butting et al. - 2018 - Modeling language variability with reusable langua.pdf:/home/hannah/Zotero/storage/PCVNM6RM/Butting et al. - 2018 - Modeling language variability with reusable langua.pdf:application/pdf},
}

@article{mendez-acuna_leveraging_2016,
	title = {Leveraging {Software} {Product} {Lines} {Engineering} in the development of external {DSLs}: {A} systematic literature review},
	volume = {46},
	issn = {1477-8424},
	shorttitle = {Leveraging {Software} {Product} {Lines} {Engineering} in the development of external {DSLs}},
	url = {https://www.sciencedirect.com/science/article/pii/S1477842416300768},
	doi = {10.1016/j.cl.2016.09.004},
	abstract = {The use of domain-specific languages (DSLs) has become a successful technique in the development of complex systems. Consequently, nowadays we can find a large variety of DSLs for diverse purposes. However, not all these DSLs are completely different; many of them share certain commonalities coming from similar modeling patterns – such as state machines or petri nets – used for several purposes. In this scenario, the challenge for language designers is to take advantage of the commonalities existing among similar DSLs by reusing, as much as possible, formerly defined language constructs. The objective is to leverage previous engineering efforts to minimize implementation from scratch. To this end, recent research in software language engineering proposes the use of product line engineering, thus introducing the notion of language product lines. Nowadays, there are several approaches that result useful in the construction of language product lines. In this article, we report on an effort for organizing the literature on language product line engineering. More precisely, we propose a definition for the life-cycle of language product lines, and we use it to analyze the capabilities of current approaches. In addition, we provide a mapping between each approach and the technological space it supports.},
	language = {en},
	urldate = {2022-12-18},
	journal = {Computer Languages, Systems \& Structures},
	author = {Méndez-Acuña, David and Galindo, José A. and Degueule, Thomas and Combemale, Benoît and Baudry, Benoît},
	month = nov,
	year = {2016},
	keywords = {Domain-specific languages, Software language engineering, Software Product Lines Engineering, Variability management},
	pages = {206--235},
	file = {Full Text:/home/hannah/Zotero/storage/IABP3WRA/Méndez-Acuña et al. - 2016 - Leveraging Software Product Lines Engineering in t.pdf:application/pdf;ScienceDirect Snapshot:/home/hannah/Zotero/storage/FVDXXSK7/S1477842416300768.html:text/html},
}

@inproceedings{kuhn_choosy_2015,
	address = {New York, NY, USA},
	series = {{SPLC} '15},
	title = {Choosy and picky: configuration of language product lines},
	isbn = {978-1-4503-3613-0},
	shorttitle = {Choosy and picky},
	url = {https://doi.org/10.1145/2791060.2791092},
	doi = {10.1145/2791060.2791092},
	abstract = {Although most programming languages naturally share several language features, they are typically implemented as a monolithic product. Language features cannot be plugged and unplugged from a language and reused in another language. Some modular approaches to language construction do exist but composing language features requires a deep understanding of its implementation hampering their use. The choose and pick approach from software product lines provides an easy way to compose a language out of a set of language features. However, current approaches to language product lines are not sufficient enough to cope with the complexity and evolution of real world programming languages. In this work, we propose a general light-weight bottom-up approach to automatically extract a feature model from a set of tagged language components. We applied this approach to the Neverlang language development framework and developed the AiDE tool to guide language developers towards a valid language composition. The approach has been evaluated on a decomposed version of Javascript to highlight the benefits of such a language product line.},
	urldate = {2022-12-18},
	booktitle = {Proceedings of the 19th {International} {Conference} on {Software} {Product} {Line}},
	publisher = {Association for Computing Machinery},
	author = {Kühn, Thomas and Cazzola, Walter and Olivares, Diego Mathias},
	month = jul,
	year = {2015},
	keywords = {language composition, language product lines},
	pages = {71--80},
	file = {Accepted Version:/home/hannah/Zotero/storage/ICF7MAJ9/Kühn et al. - 2015 - Choosy and picky configuration of language produc.pdf:application/pdf},
}

@article{krahn_monticore_2010,
	title = {{MontiCore}: a framework for compositional development of domain specific languages},
	volume = {12},
	issn = {1433-2787},
	shorttitle = {{MontiCore}},
	url = {https://doi.org/10.1007/s10009-010-0142-1},
	doi = {10.1007/s10009-010-0142-1},
	abstract = {Domain specific languages (DSLs) are increasingly used today. Coping with complex language definitions, evolving them in a structured way, and ensuring their error freeness are the main challenges of DSL design and implementation. The use of modular language definitions and composition operators are therefore inevitable in the independent development of language components. In this article, we discuss these arising issues by describing a framework for the compositional development of textual DSLs and their supporting tools. We use a redundance-free definition of a readable concrete syntax and a comprehensible abstract syntax as both representations significantly overlap in their structure. For enhancing the usability of the abstract syntax, we added concepts like associations and inheritance to a grammar-based definition in order to build up arbitrary graphs (as known from metamodeling). Two modularity concepts, grammar inheritance and embedding, are discussed. They permit compositional language definition and thus simplify the extension of languages based on already existing ones. We demonstrate that compositional engineering of new languages is a useful concept when project-individual DSLs with appropriate tool support are defined.},
	language = {en},
	number = {5},
	urldate = {2022-12-18},
	journal = {International Journal on Software Tools for Technology Transfer},
	author = {Krahn, Holger and Rumpe, Bernhard and Völkel, Steven},
	month = sep,
	year = {2010},
	keywords = {Composition, Domain specific language, Grammarware},
	pages = {353--372},
	file = {Full Text PDF:/home/hannah/Zotero/storage/ZXYBMG4P/Krahn et al. - 2010 - MontiCore a framework for compositional developme.pdf:application/pdf},
}

@misc{noauthor_elpi_2022,
	title = {{ELPI} - {Embeddable} lambda {Prolog} {Interpreter}},
	copyright = {LGPL-2.1},
	url = {https://github.com/LPCIC/elpi},
	abstract = {Embeddable Lambda Prolog Interpreter},
	urldate = {2022-12-18},
	publisher = {Prolog and the Calculus of Inductive Constructions},
	month = nov,
	year = {2022},
	note = {https://github.com/LPCIC/elpi},
	keywords = {constraints, extension-language, lambda-prolog, ocaml-library},
}

@misc{noauthor_teyjusteyjus_2022,
	title = {teyjus/teyjus},
	copyright = {GPL-3.0},
	url = {https://github.com/teyjus/teyjus},
	abstract = {An efficient implementation of the higher-order logic programming language Lambda Prolog},
	urldate = {2022-12-18},
	publisher = {teyjus},
	month = nov,
	year = {2022},
	note = {https://github.com/teyjus/teyjus},
}

@misc{noauthor_abella_nodate,
	title = {Abella},
	url = {http://abella-prover.org/walkthrough.html},
	urldate = {2022-12-18},
	note = {http://abella-prover.org/walkthrough.html},
	file = {Abella\: Walkthrough:/home/hannah/Zotero/storage/ASCJQN4Y/walkthrough.html:text/html},
}

@techreport{flatt_reference_2010,
	title = {Reference: {Racket}},
	number = {PLT-TR-2010-1},
	institution = {PLT Design Inc.},
	author = {Flatt, Matthew and {PLT}},
	year = {2010},
	annote = {https://racket-lang.org/tr1/},
}

@inproceedings{kats_spoofax_2010,
	address = {New York, NY, USA},
	series = {{OOPSLA} '10},
	title = {The spoofax language workbench: rules for declarative specification of languages and {IDEs}},
	isbn = {978-1-4503-0203-6},
	shorttitle = {The spoofax language workbench},
	url = {https://doi.org/10.1145/1869459.1869497},
	doi = {10.1145/1869459.1869497},
	abstract = {Spoofax is a language workbench for efficient, agile development of textual domain-specific languages with state-of-the-art IDE support. Spoofax integrates language processing techniques for parser generation, meta-programming, and IDE development into a single environment. It uses concise, declarative specifications for languages and IDE services. In this paper we describe the architecture of Spoofax and introduce idioms for high-level specifications of language semantics using rewrite rules, showing how analyses can be reused for transformations, code generation, and editor services such as error marking, reference resolving, and content completion. The implementation of these services is supported by language-parametric editor service classes that can be dynamically loaded by the Eclipse IDE, allowing new languages to be developed and used side-by-side in the same Eclipse environment.},
	urldate = {2022-12-18},
	booktitle = {Proceedings of the {ACM} international conference on {Object} oriented programming systems languages and applications},
	publisher = {Association for Computing Machinery},
	author = {Kats, Lennart C.L. and Visser, Eelco},
	month = oct,
	year = {2010},
	keywords = {domain-specific language, dsl, eclipse, IDE, language workbench, meta-tooling, sdf, sglr, spoofax, stratego},
	pages = {444--463},
}
